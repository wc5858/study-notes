<html>
<head>
  <title>Module语法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307881 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1734"/>
<h1>Module语法</h1>

<div>
<span><div><div>ES6 模块的设计思想是尽量的静态化，使得<span style="color: rgb(255, 0, 0);">编译时</span>就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西</div><div><br/></div><div>CommonJS 模块就是对象，输入时必须查找对象属性</div><div><span style="color: rgb(255, 0, 0);">ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">ES6 的模块自动采用<a href="https://app.yinxiang.com/shard/s71/nl/14653086/e5af321e-0bb1-47d1-a4db-98a95e829ee0">严格模式</a></span></div><div><hr/></div><div><font style="font-size: 14pt;"><b>export</b></font></div><div>export命令用于规定模块的对外接口</div><div>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// profile.js</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export var firstName = 'Michael';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export var lastName = 'Jackson';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export var year = 1958;</span></div></div><div>等价为</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// profile.js</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var firstName = 'Michael';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var lastName = 'Jackson';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var year = 1958;</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export {firstName, lastName, year};</span></div></div><div><br/></div><div>可以用<font style="color: rgb(255, 70, 53);">as</font>重命名，可以用不同的名字输出多次</div><div><br/></div><div>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 报错</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export 1;</span></div><div><span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000">// 报错</font></span></div><div><span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000">var m = 1;</font></span></div><div><span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000">export m;</font></span></div></div><div><br/></div><div><font style="color: rgb(255, 0, 0);"><b>另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</b></font></div><div>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新</div><div><br/></div><div>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。<font style="color: rgb(255, 0, 0);">如果处于块级作用域内，就会报错</font>，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了</div><div><br/></div><div>=============================</div><div><span style="font-size: 14pt; font-weight: bold;">import</span><br/></div><div>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</div><div>变量名须与接口名一致，或使用as关键字</div><div><br/></div><div>import命令输入的变量都是<b><font style="color: rgb(255, 0, 0);">只读</font></b>的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</div><div>（不过对象可以修改属性，也就是说，“浅只读”）</div><div><br/></div><div>from指定路径或者模块名（通过配置文件指定）</div><div><br/></div><div><font style="color: rgb(255, 0, 0);">import命令具有提升效果，会提升到整个模块的头部，首先执行</font></div><div><font style="color: rgb(255, 0, 0);"><b>由于import是<u>静态执行</u>，所以不能使用表达式和变量</b></font></div><div><br/></div><div>可以执行模块而不输入值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import 'lodash';</span></div></div><div><br/></div><div><font><font color="#FF0000">多次重复执行同一句import语句，那么只会执行一次，</font>也就是说，import语句是 Singleton 模式</font></div><div><br/></div><div style="margin-left: 40px;">目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。<br/></div><div><br/></div><div>=============================================================</div><div>模块整体加载</div><div>符号*指定加载对象</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import * as circle from './circle';</span></div></div><div><br/></div><div>==============================</div><div>export default命令，为模块指定默认输出</div><div><br/></div><div>此时，import命令可以为该输出指定任意名字，export default命令只能使用一次且不需要大括号</div><div><br/></div><div>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 正确</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export var a = 1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 正确</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var a = 1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export default a;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 错误</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export default var a = 1;</span></div></div><div>可以直接将一个值写在export default之后</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export default 42;</span></div></div><div><br/></div><div>如果想在一条import语句中，<font style="color: rgb(255, 0, 0);">同时输入默认方法和其他接口</font>，可以写成下面这样。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import _, { each, each as forEach } from 'lodash';</span></div></div><div><br/></div><div>export default也可以用来输出类。</div><div>=============================</div><div>复合写法</div><div>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export { foo, bar } from 'my_module';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 可以简单理解为</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import { foo, bar } from 'my_module';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export { foo, bar };</span></div><div><span style="font-family: Monaco; font-size: 9pt;">// <span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，</span><span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000"><b>导致当前模块不能直接使用foo和bar</b></font></span></span></div></div><div><br/></div><div><img src="Module语法_files/Image.png" type="image/png" data-filename="Image.png" width="481"/></div><div><br/></div><div><img src="Module语法_files/Image [1].png" type="image/png" data-filename="Image.png" width="481"/></div><div>==================================================================</div><div>模块继承</div><div><img src="Module语法_files/Image [2].png" type="image/png" data-filename="Image.png" width="502"/></div><div>===================================================================</div><div>跨模块常量</div><div>const声明的常量只在当前代码块有效，跨模块时需要export</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// constants.js 模块</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export</span> <span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000">const</font></span> <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">A = 1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export const B = 3;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">export const C = 4;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// test1.js 模块</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import * as constants from './constants';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">console.log(constants.A); // 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">console.log(constants.B); // 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// test2.js 模块</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import {A, B} from './constants';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">console.log(A); // 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">console.log(B); // 3</span></div></div><div><br/></div><div>===============================================</div><div><b>提案：import()函数，完成动态加载</b></div><div><br/></div><div>（因为import命令会被 JavaScript 引擎静态分析；如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。）</div><div><br/></div><div>import()类似于 Node 的require方法</div><div>适用于：</div><ol><li><div>按需加载</div></li><li><div>条件加载</div></li><li><div>动态加载路径</div></li></ol><div><br/></div><div>import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 