<html>
<head>
  <title>Module 的加载实现</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307881 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1733"/>
<h1>Module 的加载实现</h1>

<div>
<span><div><span style="font-size: 16pt;"><a href="https://app.yinxiang.com/shard/s71/nl/14653086/9269ca93-37c3-4fe4-9f2e-15f476726118" style="font-size: 16pt;">浏览器加载</a></span></div><div><br/></div><div>传统方法，具体略：defer是“渲染完再执行”，async是“下载完就执行”</div><div><br/></div><div>type=&quot;module&quot; es6模块脚本：</div><div>浏览器对于带有type=&quot;module&quot;的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。</div><div><br/></div><div><img src="https://html.spec.whatwg.org/images/asyncdefer.svg"></img></div><div>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</div><div><br/></div><div>对于外部的模块脚本（上例是foo.js），有几点需要注意。</div><div>* 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</div><div>* 模块脚本自动采用严格模式，不管有没有声明use strict。</div><div>* 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</div><div>* 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</div><div>* 同一个模块如果加载多次，将只执行一次。</div><div><br/></div><div>=============================================================</div><div><span style="font-size: 16pt;">ES6 模块与 CommonJS 模块的差异</span></div><div><br/></div><div>两个重大差异</div><div>* CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是<span style="color: rgb(255, 0, 0);">值的引用</span>。</div><div>* CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</div><div><br/></div><div>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错</div><div><br/></div><div>export通过接口，输出的是同一个值。<span style="color: rgb(255, 0, 0);">不同的脚本加载这个接口，得到的都是同样的实例</span></div><div>=============================================================</div><div><span style="font-size: 16pt;">Node</span></div><div>Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。</div><div>目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。</div><div><br/></div><div>Node 要求 ES6 模块采用.mjs后缀文件名</div><div>为了与浏览器的import加载规则相同，Node 的.mjs文件支持 URL 路径。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1</span></div></div><div>同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存，由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义</div><div><br/></div><div>如果模块名不含路径，那么import命令会去node_modules目录寻找这个模块</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">加载顺序</span></div><div>如果脚本文件省略了后缀名，比如import './foo'，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。</div><div>如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。</div><div>如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。</div><div>如果以上四个文件还是都不存在，就会抛出错误。</div><div><br/></div><div>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。</div><div>为了达到这个目标，Node 规定 <span style="color: rgb(255, 0, 0);">ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量</span>。</div><div><br/></div><div>ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块</div><div>以下这些顶层变量在 ES6 模块之中都是不存在的</div><div>* arguments</div><div>* require</div><div>* module</div><div>* exports</div><div>* __filename</div><div>* __dirname</div><div><br/></div><div>如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 <span style="color: rgb(255, 0, 0);">ES6 模块加载这个 CommonJS 模块</span>。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">ES6模块加载commonJS模块</span></div><div>CommonJS 模块的输出都定义在module.exports这个属性上面。</div><div>Node 的import命令加载 CommonJS 模块，<span style="font-weight: bold;">Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx</span>。</div><div><br/></div><div>因此有三种写法，可以拿到 CommonJS 模块的module.exports</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 写法一</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import baz from './a';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// baz = {foo: 'hello', bar: 'world'};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 写法二</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import {default as baz} from './a';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// baz = {foo: 'hello', bar: 'world'};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 写法三</span></div><div><span style="font-family: Monaco; font-size: 9pt;">// <span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000">这种写法可以通过baz.default拿到module.exports</font></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">import * as baz from './a';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// baz = {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//   get default() {return module.exports;},</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//   get foo() {return this.default.foo}.bind(baz),</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//   get bar() {return this.default.bar}.bind(baz)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// }</span></div></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效</span></div><div>（所以本质上还是commonJS的模块，只不过通过es6方式加载了而已）</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;"><span style="color: rgb(255, 0, 0); font-weight: bold;">commonJS模块<span style="color: rgb(255, 0, 0); font-weight: bold;">加载</span></span>ES6模块</span></div><div>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。</div><div>ES6 模块的所有输出接口，会成为输入对象的属性。</div><div>=============================================================</div><div><span style="font-size: 16pt;">循环加载问题</span></div><div>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</div><div><br/></div><div>&gt;背景知识：CommonJS 模块格式的加载原理</div><div><span style="color: rgb(255, 0, 0);">CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象</span></div><div>即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值</div><div><br/></div><div>（运行时加载，加载时执行）</div><div>CommonJS 模块的重要特性是<span style="color: rgb(255, 0, 0);">加载时执行</span>，即脚本代码在require的时候，就会全部执行。</div><div><font style="color: rgb(255, 0, 0);">一旦出现某个模块被&quot;循环加载&quot;，就只输出已经执行的部分，还未执行的部分不会输出</font>。</div><div>（a执行b，b依赖a，b只能获取a已执行部分的输出，a剩余部分在b执行完后执行）【<a href="https://nodejs.org/api/modules.html#modules_cycles">参考</a>】</div><div><br/></div><div>因此，由于 CommonJS 模块遇到循环加载时，返回的是当前<font style="color: rgb(255, 0, 0);">已经执行的部分的值</font>，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</div><div><br/></div><div><font style="color: rgb(255, 0, 0);"><b>ES6的循环加载</b></font></div><div>ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</div><div><br/></div><div>具体讲解比较长，参看<a href="http://es6.ruanyifeng.com/?search=get&amp;x=17&amp;y=10#docs/module-loaderES6-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">阮老师的书</a></div><div>=============================================================</div><div><span style="font-size: 16pt;">模块转码</span></div><div>浏览器目前还不支持 ES6 模块</div><div>转码器:</div><div>Babel</div><div>ES6 module transpiler</div><div>SystemJS</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 