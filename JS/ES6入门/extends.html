<html>
<head>
  <title>extends</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307881 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1742"/>
<h1>extends</h1>

<div>
<span><div><div>继承语法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class ColorPoint extends Point {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor(x, y, color) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    super(x, y); // 调用父类的constructor(x, y)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    this.color = color;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  toString() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return this.color + ' ' + super.toString(); // 调用父类的toString()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div><font style="color: rgb(255, 0, 0);">子类必须在constructor方法中调用super方法</font>，否则新建实例时会报错</div><ul><li><div><span>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</span><br/></div></li></ul><div><br/></div><div>ES5 的继承（寄生组合继承），实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。</div><div>ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。（也就是说不仅仅是语法糖）</div><div>（babel编译后的polyfill则还是es5继承的实现）</div><div>因此，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。</div><div><br/></div><div>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class ColorPoint extends Point {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 等同于</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class ColorPoint extends Point {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor(...args) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    super(...args);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>父类的静态方法，也会被子类继承</div><div><br/></div><div><font color="#FF0000">Object.getPrototypeOf方法可以用来从子类上获取父类</font></div><div>（这意味着子类的原型是父类而不是父类的原型；es5寄生组合继承中，子类的原型是父类的原型，子类内部call父类构造函数）</div><div><br/></div><div><hr/></div><div>super作为函数调用时，代表父类的构造函数</div><div>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即<font style="color: rgb(255, 0, 0);">super内部的this指的是子类</font>B</div><div><br/></div><div>super作为对象时，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">在<b>普通方法中</b>，指向<font style="color: rgb(255, 0, 0);">父类的原型对象</font></span></div><div><span>由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</span></div><div><span><br/></span></div><div>ES6 规定，在<font style="color: rgb(255, 0, 0);">子类普通方法</font>中通过super调用父类的方法时，方法内部的this指向当前的子类实例。</div><div>this指向子类实例，<font style="color: rgb(255, 0, 0);"><b>所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</b></font>。</div><div>但是读取属性的时候，访问的还是父类的原型对象。此时读写表现会不一致</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class A {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    this.x = 1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class B extends A {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    super();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    this.x = 2;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51); background-color: rgb(255, 250, 165);-evernote-highlight:true;">    super.x = 3;</span></div><div><span style="font-family: Monaco; font-size: 9pt; background-color: rgb(255, 250, 165);-evernote-highlight:true;">    <b><font color="#FF0000">console.log(super.x); // undefined</font></b></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51); background-color: rgb(255, 250, 165);-evernote-highlight:true;">    console.log(this.x); // 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let b = new B();</span></div></div><div><br/></div><div>如果super作为对象，用<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">在<b>静态方法</b>之中，这时<font style="color: rgb(255, 0, 0);">super将指向父类</font></span>，而不是父类的原型对象</div><div>另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。</div><div><br/></div><div>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。（即要从语法形式上能看出来是作为函数还是作为对象）</div><div>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字</div><div><br/></div><div>====================================</div><div><br/></div><div>大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。</div><div>Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</div><div>（1）<font style="color: rgb(255, 0, 0);">子类的__proto__属性，表示构造函数的继承，总是指向父类</font>。</div><div>（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</div><div><br/></div><div>（其实es5中function也是同时有prototype属性和__proto__属性的，前者是function的作为构造函数时的原型，后者是function作为对象时的原型，</div><div><span>    </span>但是es5中的继承，直接通过call的方式调用父类构造函数，因此没有用到__proto__属性）</div><div>（也就是说es6的继承从语法上来说更完备和严谨）</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class A {}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class B extends A {}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">B.__proto__ === A // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">B.prototype.__proto__ === A.prototype // true</span></div></div><div><br/></div><div>这样的结果是因为，类的继承是按照下面的模式实现的。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class A {}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class B {}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// B 的实例继承 A 的实例</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Object.setPrototypeOf(B.prototype, A.prototype);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// B 继承 A 的静态属性</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Object.setPrototypeOf(B, A);</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const b = new B();</span></div></div><div><br/></div><div>=============================</div><div><br/></div><div>实际上，<font style="color: rgb(255, 0, 0);">只要是有prototype属性的函数，就能被继承</font></div><div><br/></div><div>特殊情况：</div><div>1.子类继承Object类</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class A extends Object {}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">A.__proto__ === Object // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">A.prototype.__proto__ === Object.prototype // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 此时A相当于<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">构造函数Object的复制</span></span></div></div><div>2.不存在任何继承</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class A {}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">A.__proto__ === Function.prototype // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">A.prototype.__proto__ === Object.prototype // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function B() {}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">B.__proto__ === Function.prototype // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">B.prototype.__proto__ === Object.prototype // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 所以此时A就相当于普通函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 其意义是：A作为对象是Function实例，A作为构造函数，其原型是Object的实例</span></div></div><div>3.子类继承null</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class A extends null {}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">A.__proto__ === Function.prototype // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">A.prototype.__proto__ === undefined // true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Function.prototype。</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向undefined，即实质上执行了下面的代码。<span>  </span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><br/></span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class C extends null {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor() { return Object.create(null); }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>==========================</div><div>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</div><div>==========================</div><div>es5中无法原生继承（通过Object.create），因为子类无法获得原生构造函数的内部属性</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function MyArray() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Array.apply(this, arguments);}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">MyArray.prototype = Object.create(Array.prototype, {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor: {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    value: MyArray,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    writable: true,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    configurable: true,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    enumerable: true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span><span style="font-family: Monaco; font-size: 9pt;">);</span></div><div><span style="font-family: Monaco; font-size: 9pt;">// <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var colors = new MyArray();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">colors[0] = &quot;red&quot;;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">colors.length  // 0</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">colors.length = 0;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">colors[0]  // &quot;red&quot;</span></div></div><div><br/></div><div>ES6 <font style="color: rgb(255, 0, 0);">允许继承原生构造函数定义子类</font>，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</div><div>（babel的polyfill也是能实现这种形式的）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 上面的自定义Array其实可以这样写（也是babel的实践）</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function MyArray() {</span></div><div><span style="font-family: Monaco; font-size: 9pt;"><b><font color="#FF0000">return</font></b> Array.apply(this, arguments);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var colors = new MyArray();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">colors[0] = &quot;red&quot;;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">console.log(colors.length) // 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// babel还另外做了处理，兼容原生构造函数和一般父类，此处略去细节</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">这是因为在原生构造函数上调用call会返回一个新对象，在一般构造函数上调用call可能返回undefined或者新对象（取决于这个构造函数的实现）</span></span></div><div><span style="font-family: Monaco; font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">//</span> <span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000">这部分的babel代码很巧妙，值得学习</font></span></span></div></div><div><br/></div><div>总之，结论就是，<font style="color: rgb(255, 0, 0);">extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数</font></div><div><br/></div><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 15.36px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">注意，继承</span><span style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Object</span><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 15.36px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">的子类，有一个</span><a href="http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object" style="background: transparent; color: rgb(70, 130, 190); font-family: Verdana, Arial; font-size: 15.36px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">行为差异</a><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 15.36px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NewObj extends Object{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor(){</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    super(...arguments);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }}var o = new NewObj({attr: true});</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">o.attr === true  // false</span></div></div><div>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。</div><div>======================================</div><div>Mixin模式：多个对象合成一个新的对象，新对象具有各个组成成员的接口</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 