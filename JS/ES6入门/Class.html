<html>
<head>
  <title>Class</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307881 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1743"/>
<h1>Class</h1>

<div>
<span><div>ES6 的class可以看作只是一个语法糖</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//定义类</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Point {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor(x, y) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    this.x = x;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    this.y = y;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  toString() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return '(' + this.x + ', ' + this.y + ')';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">typeof Point // &quot;function&quot;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Point === Point.prototype.constructor // true</span></div></div><div><br/></div><div>1.仍然用new命令构建对象</div><div>2.类中声明的方法依然是在原型上，因此依然可以像在es5中那样修改原型</div><div>3.<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">类内部所有定义的方法，都是不可枚举的（这一点与es5行为不一致）</span></div><div>4.类的方法名可以使用表达式</div><div><span style="color: rgb(255, 0, 0);">5.类和模块的内部，默认即为严格模式</span></div><div><br/></div><div>6.一个类必须有constructor方法，否则默认添加一个空的</div><div>7.constructor方法默认返回实例对象（即this）</div><div>    <span style="color: rgb(255, 0, 0);">但是可以指定返回另外一个对象，这会导致所创建的对象不是类的实例</span></div><div>8.类必须使用new调用，否则会报错</div><div><br/></div><div>9.类也可以使用表达式的形式定义</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const MyClass = class Me {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  getClassName() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return Me.name;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 此时，类名是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 不需要的话，可以省略这个Me</span></div></div><div>10.采用 Class 表达式，可以写出<span style="color: rgb(255, 0, 0);">立即执行的 Class</span></div><div><br/></div><div>11.类不存在声明提升（这种规定的原因与继承有关，必须保证子类在父类之后定义）</div><div>=======================</div><div>私有属性的问题</div><div><span style="color: rgb(255, 0, 0);">类内部的方法和属性都是公有的</span>，要实现私有，须另作处理</div><div>1.通过区分命名约定为私有（不保险）</div><div>2.私有方法移到类外，通过call方式调用</div><div>3.利用symbol的唯一性</div><div>提案：</div><div>属性名前加#声明为私有</div><div>========================</div><div>this的问题</div><div>类的方法内部如果含有this，它默认指向类的实例</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">但是，</span>如果通过解构赋值提取类中的函数使用，this会指向该方法运行时所在的环境</div><div>解决方法：</div><div>1.构造方法中绑定this</div><div>2.使用箭头函数</div><div>3.Proxy，获取方法的时候，自动绑定this</div><div>========================</div><div>其他</div><div>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</div><div><br/></div><div>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</div><div>存值函数和取值函数是设置在属性的 Descriptor 对象上的（<span style="color: rgb(235, 0, 115);">非静态方法设置在原型上，静态的设置在类上，具体可以看babel编译结果</span>）</div><div><br/></div><div>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数</div><div>=========================</div><div>静态方法</div><div>如果在一个方法前，加上<font style="color: rgb(255, 0, 0);">static关键字</font>，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</div><div>如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</div><div><font style="color: rgb(255, 0, 0);">如果静态方法包含this关键字，这个this指的是<u>类</u>，而不是实例，因此<span style="color: rgb(255, 0, 0);"><u>静态方法可以与非静态方法重名。</u></span></font></div><div><br/></div><div>父类的静态方法，可以被子类继承</div><div>静态方法也是可以从super对象上调用的</div><div>==========================</div><div>静态属性</div><div>静态属性要在类外定义（其实本质上就是es5中，function本身作为对象的属性）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Foo {}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Foo.prop = 1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Foo.prop // 1</span></div></div><div><br/></div><div>有新<a href="https://github.com/tc39/proposal-class-fields">提案</a>给出了内部属性和静态属性的写法</div><div><br/></div><div>但是，实测有一点阮老师没有提到，是可以有静态取值函数和赋值函数的</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Test {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">constructor() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">this.d = 0</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">try() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">this.d = this.x</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">return this</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">static get x() { return 5 }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">console.log(Test.x) // 5</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let t = new Test()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">console.log(t.x) // undefined</span></div></div><div><br/></div><div>babel编译过程中也是把这个属性绑定到了类上</div><div><br/></div><div>==========================</div><div>ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</div><div><br/></div><div>因为es6本身已经限制了构造函数不能作为函数使用（babel中使用了安全工厂），所以用种方式检查是否用new命令调用意义不大</div><div>不过，利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Shape {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    if (new.target === Shape) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">      throw new Error('本类不能实例化');</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Rectangle extends Shape {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor(length, width) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    </span><span style="font-family: Monaco; font-size: 9pt;"><font color="#FF0000">super();</font></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    // ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var x = new Shape();  // 报错</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">var y = new Rectangle(3, 4);  // 正确</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 