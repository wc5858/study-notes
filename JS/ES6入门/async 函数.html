<html>
<head>
  <title>async 函数</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307881 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1744"/>
<h1>async 函数</h1>

<div>
<span><div><div>Generator 函数的语法糖</div><ul><li><div>内置执行器</div></li><li><div>语义更清晰</div></li><li><div>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</div></li><li><div>async函数的返回值是 Promise 对象</div></li></ul><div>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</div><div><br/></div><div>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。</div><div>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</div><div><br/></div><div>由于async函数返回的是 Promise 对象，故可以作为await命令的参数。</div><div><br/></div><div>async 函数有多种使用形式。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 函数声明</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">async function foo() {}</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 函数表达式</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const foo = async function () {};</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 对象的方法</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let obj = { async foo() {} };</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">obj.foo().then(...)</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// Class 的方法</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Storage {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    this.cachePromise = caches.open('avatars');</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  async getAvatar(name) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    const cache = await this.cachePromise;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return cache.match(`/avatars/${name}.jpg`);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const storage = new Storage();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">storage.getAvatar('jake').then(…);</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 箭头函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const foo = async () =&gt; {};</span></div></div><div><br/></div><div><hr/><div>具体语法</div></div><div>1.async函数内部return语句返回的值，会成为then方法回调函数的参数</div><div>2.async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</div><div>3.async函数返回的 Promise 对象，必须等到<span style="color: rgb(255, 0, 0);">内部所有await命令后面的 Promise 对象执行完</span>，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</div><div>4.正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</div><div>5.await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。<span style="color: rgb(255, 0, 0);">只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。</span></div><div>6.有时，我们希望<font style="color: rgb(255, 0, 0);">即使前一个异步操作失败，也不要中断后面的异步操作</font>。</div><div>    方法一：将前一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</div><div>    方法二：await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。（把reject状态处理成resolve状态）</div><div>7.如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。防止出错的方法，也是将其放在try...catch代码块之中。</div><div><span>    （参考Promise，其实reject等同于抛出错误，进一步导致了async函数返回的promise被reject）</span><br/></div><div><img src="async 函数_files/Image.png" type="image/png" data-filename="Image.png" width="488"/></div><div>8.同步触发与异步触发（注意是触发，但是结果还是异步的）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 异步触发：foo完成后才会触发bar</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let foo = await getFoo();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let bar = await getBar();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 同步触发</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 写法一</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 写法二</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let fooPromise = getFoo();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let barPromise = getBar();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let foo = await fooPromise;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let bar = await barPromise;</span></div></div><div><br/></div><div>9.await命令只能用在async函数之中，如果用在普通函数，就会报错。</div><div><span>    不过，</span>目前esm模块加载器支持顶层await，即await命令可以不放在 async 函数里面，直接使用。<br/></div><div>=======================================</div><div>async 函数的实现原理</div><div>将 Generator 函数和自动执行器，包装在一个函数里。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">async function fn(args) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 等同于</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function fn(args) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return spawn(function* () {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    // <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">spawn函数就是自动执行器</span></span><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    // ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  });</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>Async 函数的实现最简洁。如果使用 Generator 写法，自动执行器需要用户自己提供。</div><div><br/></div><div>==============</div><div>实例：并发异步</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">async function logInOrder(urls) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 并发读取远程URL</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const textPromises = urls.map(async url =&gt; {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    const response = await fetch(url);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return response.text();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  });</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 按次序输出</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  for (const textPromise of textPromises) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    console.log(await textPromise);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>=====================</div><div>ES2018：异步遍历器</div><div>异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。</div><div>对象的异步遍历器接口，部署在<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Symbol.asyncIterator</span>属性上面</div><div>注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的 Promise 对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。</div><div><br/></div><div>新引入<b><font style="color: rgb(255, 0, 0);">for await...of</font></b>循环，用于遍历异步的 Iterator 接口。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">async function f() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  for await (const x of createAsyncIterable(['a', 'b'])) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    console.log(x);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// a</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// b</span></div></div><div><br/></div><div>上面代码中，createAsyncIterable()返回一个拥有异步遍历器接口的对象，for...of循环自动调用这个对象的异步遍历器的next方法，会得到一个 Promise 对象。await用来处理这个 Promise 对象，一旦resolve，就把得到的值（x）传入for...of的循环体。</div><div><br/></div><div>如果next方法返回的 Promise 对象被reject，for await...of就会报错，要用try...catch捕捉。</div><div><br/></div><div>for await...of循环也可以用于同步遍历器</div><div><br/></div><div><font style="color: rgb(255, 0, 0);"><b>异</b></font><font style="color: rgb(255, 0, 0);"><b>步 Generator 函数的作用，是返回一个异步遍历器对象</b></font></div><div>语法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">async function* gen() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  yield 'hello';</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const genObj = gen();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">genObj.next().then(x =&gt; console.log(x));</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// { value: 'hello', done: false }</span></div></div><div><br/></div><div>异步 Generator 函数内部，能够同时使用await和yield命令。可以这样理解，await命令用于将外部操作产生的值输入函数内部，yield命令用于将函数内部的值输出。</div><div>异步 Generator 函数的返回值是一个异步 Iterator，即每次调用它的next方法，会返回一个 Promise 对象，也就是说，跟在yield命令后面的，应该是一个 Promise 对象。如果像上面那个例子那样，yield命令后面是一个字符串，会被自动包装成一个 Promise 对象。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象。可以这样理解，async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，<u>前者自带执行器，后者通过for await...of执行，或者自己编写执行器</u>。</span></div><div><br/></div><div>异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：</div><div><span>    </span>普通函数</div><div><span>    </span>async 函数</div><div><span>    </span>Generator 函数</div><div><span>    </span>异步 Generator 函数。</div><div><br/></div><div>yield*语句也可以跟一个异步遍历器。for await...of循环会展开yield*。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 